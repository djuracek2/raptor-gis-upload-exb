/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{clamp as t}from"../../../../../../../core/mathUtils.js";import{pt2px as e}from"../../../../../../../core/screenUtils.js";import{GeometryCursor as o}from"../../../../../../../geometry/GeometryCursor.js";import{CIMMarkerPlacementHelper as r}from"../../../../../../../symbols/cim/placements/CIMMarkerPlacementHelper.js";import{getXDirection as i,getYDirection as s}from"../../../alignmentUtils.js";import{minMaxZoomPrecisionFactor as n,magicLabelLineHeight as a,glyphSize as c}from"../../../definitions.js";import{shapeGlyphs as l}from"../../../mesh/templates/shapingUtils.js";import{packBitset as h,processColorInput as p}from"../fill/meshWriterUtils.js";import{getGeometryEngine as f}from"../mesh/loadGeometryEngine.js";import{MeshWriter as m}from"../mesh/MeshWriter.js";import{bitsetTextIsBackground as d,bitsetTextIsMapAligned as u}from"../shaders/constants.js";import{TextMeshTransformProps as g}from"./TextParams.js";import{DataType as x}from"../../../../../../webgl/enums.js";const y=28,_=[4,4],P=[16,4],S={topLeft:P,topRight:P,bottomLeft:P,bottomRight:P},k=[4,2],b=[4,6],T={topLeft:k,topRight:k,bottomLeft:b,bottomRight:b},B={topLeft:k,topRight:b,bottomLeft:k,bottomRight:b},R={topLeft:b,topRight:b,bottomLeft:_,bottomRight:_},w={topLeft:_,topRight:_,bottomLeft:b,bottomRight:b},M={topLeft:b,topRight:_,bottomLeft:b,bottomRight:_},z={topLeft:_,topRight:b,bottomLeft:_,bottomRight:b},L={createComputedParams:t=>t,attributes:{pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>h([[d,t],[u,!!e]])},zoomRange:{type:x.UNSIGNED_SHORT,count:2,packPrecisionFactor:n,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||y]},offset:{type:x.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:o,topLeft:r,topRight:i}=t;return[r,i,e,o]}}},textureUV:{type:x.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:o,topLeft:r,topRight:i}=t;return[r,i,e,o]}}},color:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontSize:{type:x.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t})=>e(t)},referenceSize:{type:x.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:o})=>e(o??t)},haloColor:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>p(t)},haloFontSize:{type:x.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,pack:({haloFontSize:t})=>e(t)},clipAngle:{type:x.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>G(t||0)},referenceSymbol:{type:x.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,o)=>{if(!t.referenceBounds)return[0,0,0,0];const r=i(o.horizontalAlignment),n=s(o.verticalAlignment),{offsetX:a,offsetY:c,size:l}=t.referenceBounds;return[e(a),-e(c),e(l),r+1<<2|n+1]}}}};class E extends m{constructor(){super(...arguments),this.vertexSpec=L,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,o){super.ensurePacked(t,e,o),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new g(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,o){const r=this._getShaping();if(!r)return;const i=e.getDisplayId();if(null!=this.evaluatedMeshParams.placement)return this._writePlacedTextMarkers(t,e,r,o);if(o&&o.nextPath())return o.nextPoint(),this._writeGlyphs(t,i,o.x,o.y,r,0);if("esriGeometryPolygon"===e.geometryType){const o=e.readCentroidForDisplay();if(!o)return;const[s,n]=o.coords;return this._writeGlyphs(t,i,s,n,r,0)}if("esriGeometryMultipoint"===e.geometryType){const o=e.readGeometryForDisplay();return void o?.forEachVertex(((e,o)=>this._writeGlyphs(t,i,e,o,r,0)))}const s=e.readXForDisplay(),n=e.readYForDisplay();return this._writeGlyphs(t,i,s,n,r,0)}_writePlacedTextMarkers(t,i,s,n){const a=n??o.fromFeatureSetReaderCIM(i);if(!a)return;const c=-1,l=r.getPlacement(a,c,this.evaluatedMeshParams.placement,e(1),t.id,f());if(!l)return;const h=i.getDisplayId();let p=l.next();for(;null!=p;){const e=p.tx,o=-p.ty,r=-p.getAngle();this._writeGlyphs(t,h,e,o,s,r),p=l.next()}}_getShaping(){const o=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!r.glyphs?.glyphs.length)return null;const i=Math.round(e(o.fontSize)),s=e(o.offsetX),n=e(o.offsetY),h=t(e(r.lineWidth),32,512),p=a*t(r.lineHeightRatio,.25,4);return l(r.glyphs,{scale:i/c,angle:o.postAngle,xOffset:s,yOffset:n,horizontalAlignment:r.horizontalAlignment,verticalAlignment:r.verticalAlignment,maxLineWidth:h,lineHeight:p,decoration:r.decoration,borderLineSizePx:e(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(t,o,r,i,s,n,a){const c=this.evaluatedMeshParams,l=this._textMeshTransformProps,h=l.fontSize,f=e(l.offsetX),m=e(l.offsetY);0!==n&&s.setRotation(n);const d=s.bounds,u=r+d.x+f,g=i+d.y-m,x=2*(c.minPixelBuffer?c.minPixelBuffer/h:1),y=Math.max(d.width,d.height)*x;s.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,s.glyphs[0].textureBinding),t.recordBounds(u,g,y,y),this._writeTextBox(t,o,r,i,s.textBox,a),t.recordEnd());for(const e of s.glyphs){t.recordStart(this.instanceId,this.attributeLayout,e.textureBinding),t.recordBounds(u,g,y,y);const{texcoords:s,offsets:n}=e;this._writeQuad(t,o,r,i,{texcoords:s,offsets:n,fontSize:h,color:p(c.color),isBackground:!1,referenceBounds:a}),t.recordEnd()}0!==n&&s.setRotation(-n)}_writeTextBox(t,e,o,r,i,s,n){const a=this.evaluatedMeshParams,{fontSize:c}=this._textMeshTransformProps,{boxBackgroundColor:l,boxBorderLineColor:h}=a,f={isBackground:!0,fontSize:c,referenceBounds:s,...n};l&&(this._writeQuad(t,e,o,r,{texcoords:S,offsets:i.main,color:p(l),...f}),h||(this._writeQuad(t,e,o,r,{texcoords:R,offsets:i.top,color:p(l),...f}),this._writeQuad(t,e,o,r,{texcoords:w,offsets:i.bot,color:p(l),...f}),this._writeQuad(t,e,o,r,{texcoords:M,offsets:i.left,color:p(l),...f}),this._writeQuad(t,e,o,r,{texcoords:z,offsets:i.right,color:p(l),...f}))),h&&(this._writeQuad(t,e,o,r,{texcoords:T,offsets:i.top,color:p(h),...f}),this._writeQuad(t,e,o,r,{texcoords:T,offsets:i.bot,color:p(h),...f}),this._writeQuad(t,e,o,r,{texcoords:B,offsets:i.left,color:p(h),...f}),this._writeQuad(t,e,o,r,{texcoords:B,offsets:i.right,color:p(h),...f}))}_writeQuad(t,e,o,r,i){const s=t.vertexCount();this._writeVertex(t,e,o,r,i),t.indexWrite(s+0),t.indexWrite(s+1),t.indexWrite(s+2),t.indexWrite(s+1),t.indexWrite(s+3),t.indexWrite(s+2)}}const G=t=>Math.round(t*(254/360));export{E as TextMeshWriter,L as TextVertexSpec,y as maxLabelZoom};
