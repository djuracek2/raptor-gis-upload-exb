/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{memoize as e}from"../../../../../../../core/MapUtils.js";import{fromRotation as t}from"../../../../../../../core/libs/gl-matrix-2/math/mat2d.js";import{create as i}from"../../../../../../../core/libs/gl-matrix-2/factories/mat2df32.js";import{getXAnchorDirection as s,getYAnchorDirection as a}from"../../../alignmentUtils.js";import{getDisplayIdTexel as n}from"../../../DisplayId.js";import{LabelMetric as r}from"../../../collisions/LabelMetric.js";import{smoothPaths as o,pathDivide as l}from"../../../mesh/templates/segmentUtils.js";import{getMinMaxZoom as h,processColorInput as c}from"../fill/meshWriterUtils.js";import{TextMeshWriter as m,maxLabelZoom as d}from"../text/TextMeshWriter.js";const u=1,g=0,p=128,f=e((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class x extends m{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,i,s){if(this._zoomLevel=s||0,null!=i)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const i=t.readXForDisplay(),s=t.readYForDisplay();return this._writePoint(e,i,s,t)}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const i=t.readCentroidForDisplay();if(!i)return;const[s,a]=i.coords;return this._writePoint(e,s,a,t)}case"esriGeometryPolyline":{const i=t.readLegacyGeometryForDisplay();this._writeLines(e,t,i)}}}_writePoint(e,t,i,o){const l=this._getShaping();if(!l)return;let h=this._getPointReferenceBounds();h||(h={offsetX:0,offsetY:0,size:0});const c=l.boundsT,m=s(this.evaluatedMeshParams.horizontalAlignment),d=a(this.evaluatedMeshParams.verticalAlignment),u=this.evaluatedMeshParams.scaleInfo?.maxScale??0,g=this.evaluatedMeshParams.scaleInfo?.minScale??0,p=n(o.getDisplayId());e.metricStart(new r(p,t,i,m,d,u,g,h)),e.metricBoxWrite(c),this._writeGlyphs(e,o.getDisplayId(),t,i,l,0,h),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t,i){const{repeatLabel:s,scaleInfo:a}=this.evaluatedMeshParams,n=this.evaluatedMeshParams.repeatLabelDistance||128,r=this._getShaping();if(!r)return;this._current={out:e,id:t.getDisplayId(),shaping:r,zoomRange:h(a,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0}};const c=o(i.paths,r.bounds.width),m=this._placeSubdivGlyphs.bind(this),d=(r.bounds.width+n)/(1<<u);for(const o of c)l(o,d,m,!!s)}_placeSubdivGlyphs(e,t,i,s){const{allowOverrun:a,labelPosition:n,repeatLabelDistance:r}=this.evaluatedMeshParams,o=this._current.zoomRange[0],l=f(t),h=this._current.shaping.bounds.width/(1<<u),c=Math.sqrt(r||p)/(1<<u),m=Math.min(i,s-i),g=this._current.shaping.isMultiline?d:Math.log2(m/(c+h/2)),x=0===t?g:Math.min(l,g),_=Math.max(o,this._zoomLevel+u-x),M=this._zoomLevel-_,y=this._current.shaping.bounds.width/2*2**M;this._current.shaping.isMultiline?0===t&&this._placeStraight(e,_):a&&M<0?this._placeStraightAlong(e,o):"parallel"===n?this._placeStraightAlong(e,_):"curved"===n&&this._placeCurved(e,_,y)}_placeStraight(e,s){const{out:a,id:o,shaping:l,zoomRange:h,referenceBounds:c}=this._current,{x:m,y:u}=e,g=e.angle*(180/Math.PI)%360,p=(e.angle*(180/Math.PI)+180)%360;if(l.textBox){const n=Math.max(s,h[0],0),r=Math.min(d,h[1]),m=t(i(),-e.angle),[u,f]=l.shapeBackground(m),x={minZoom:n,maxZoom:r,clipAngle:g,mapAligned:!0,isLineLabel:!0};a.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding),this._writeTextBox(a,o,e.x,e.y,f,c,x),a.recordEnd(),x.clipAngle=p,a.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding),this._writeTextBox(a,o,e.x,e.y,f,c,x),a.recordEnd()}const f=n(o),x=this.evaluatedMeshParams.scaleInfo?.maxScale??0,_=this.evaluatedMeshParams.scaleInfo?.minScale??0;a.metricStart(new r(f,e.x,e.y,0,0,x,_,null)),a.metricBoxWrite(l.bounds);for(const t of l.glyphs)t.minZoom=s,t.maxZoom=h[1],t.angle=e.angle,this._writeLineGlyph(a,o,m,u,l.bounds,t,g,c,!0),t.angle=e.angle+Math.PI,this._writeLineGlyph(a,o,m,u,l.bounds,t,p,c,!0);a.metricEnd()}_placeCurved(e,t,i){const{out:s,id:a}=this._current,o=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360,c=n(a),m=this.evaluatedMeshParams.scaleInfo?.maxScale??0,d=this.evaluatedMeshParams.scaleInfo?.minScale??0;s.metricStart(new r(c,e.x,e.y,0,0,m,d,null)),this._placeFirst(o,t,1,l),this._placeBack(e,o,t,i,1,l),this._placeForward(e,o,t,i,1,l),this._placeFirst(o,t,0,h),this._placeBack(e,o,t,i,0,h),this._placeForward(e,o,t,i,0,h),s.metricEnd()}_placeStraightAlong(e,s){const{out:a,id:o,shaping:l,zoomRange:h,referenceBounds:c}=this._current,{boxBorderLineColor:m,boxBackgroundColor:u}=this.evaluatedMeshParams,g=e.clone(),p=e.angle*(180/Math.PI)%360,f=(e.angle*(180/Math.PI)+180)%360;if(l.glyphs.length>0&&(m||u)){const n=Math.max(s,h[0],0),r=Math.min(d,h[1]),m=t(i(),-e.angle),[u,g]=l.shapeBackground(m),x={minZoom:n,maxZoom:r,clipAngle:p,mapAligned:!0,isLineLabel:!0};a.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding),this._writeTextBox(a,o,e.x,e.y,g,c,x),a.recordEnd(),x.clipAngle=f,a.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding),this._writeTextBox(a,o,e.x,e.y,g,c,x),a.recordEnd()}const x=n(o),_=this.evaluatedMeshParams.scaleInfo?.maxScale??0,M=this.evaluatedMeshParams.scaleInfo?.minScale??0;a.metricStart(new r(x,e.x,e.y,0,0,_,M,null)),this._placeFirst(g,s,1,p,!0),this._placeFirst(g,s,0,f,!0),a.metricEnd()}_placeBack(e,t,i,s,a,n){const r=e.clone();let o=e.backwardLength+g;for(;r.prev()&&!(o>=s);)this._placeOnSegment(r,t,o,i,-1,a,n),o+=r.length+g}_placeForward(e,t,i,s,a,n){const r=e.clone();let o=e.remainingLength+g;for(;r.next()&&!(o>=s);)this._placeOnSegment(r,t,o,i,1,a,n),o+=r.length+g}_placeFirst(e,t,i,s,a=!1){const n=e,{out:r,id:o,shaping:l,zoomRange:h,referenceBounds:c}=this._current,m=l.glyphs;for(const u of m){const m=u.x>l.bounds.x?i:1-i,p=m*e.remainingLength+(1-m)*e.backwardLength,f=Math.abs(u.x+u.width/2-l.bounds.x),x=Math.max(0,this._zoomLevel+Math.log2(f/(p+g))),_=Math.max(t,a?0:x);u.maxZoom=Math.min(h[1],d),u.angle=e.angle+(1-i)*Math.PI,u.minZoom=Math.max(h[0],_),r.metricBoxWrite(u.bounds),this._writeLineGlyph(r,o,n.x,n.y,l.bounds,u,s,c,!0)}}_placeOnSegment(e,t,i,s,a,n,r){const{out:o,id:l,shaping:h,referenceBounds:c}=this._current,m=h.glyphs,d=e.dx/e.length,u=e.dy/e.length,p={x:e.x+i*-a*d,y:e.y+i*-a*u};for(const f of m){const t=f.x>h.bounds.x?n:1-n;if(!(t&&1===a||!t&&-1===a))continue;const m=Math.abs(f.x+f.width/2-h.bounds.x),d=Math.max(0,this._zoomLevel+Math.log2(m/i)-.1),u=Math.max(s,this._zoomLevel+Math.log2(m/(i+e.length+g)));0!==d&&(f.angle=e.angle+(1-n)*Math.PI,f.minZoom=u,f.maxZoom=d,this._writeLineGlyph(o,l,p.x,p.y,h.bounds,f,r,c,!0))}}_writeLineGlyph(e,t,i,s,a,n,r,o,l){const h=i+a.x,m=s+a.y,d=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),u=Math.max(a.width,a.height)*d;e.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),e.recordBounds(h,m,u,u);const{texcoords:g,offsets:p}=n,f=this._textMeshTransformProps.fontSize;this._writeQuad(e,t,i,s,{texcoords:g,offsets:p,fontSize:f,color:c(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:o,minZoom:Math.max(this._current.zoomRange[0],n.minZoom),maxZoom:Math.min(this._current.zoomRange[1],n.maxZoom),clipAngle:r,mapAligned:l,isLineLabel:!0}),e.recordEnd()}}export{x as LabelMeshWriter};
