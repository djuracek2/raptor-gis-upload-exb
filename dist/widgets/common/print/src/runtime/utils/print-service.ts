import { type UseUtility, Immutable, type ImmutableArray } from 'jimu-core'
import { loadArcGISJSAPIModules, type JimuMapView } from 'jimu-arcgis'
import { type MapView, type PrintTemplateProperties } from '../../config'
import { getUrlOfUseUtility, reportUtilityState } from '../../utils/utils'
import { getSessionByUtility } from '../../utils/service-util'
import { removeReportLayers } from './utils'
interface PrintOption {
  useUtility?: UseUtility
  mapView: MapView
  printTemplateProperties: PrintTemplateProperties
  isSupportReport?: boolean
  widgetId?: string
  useMapWidgetIds?: ImmutableArray<string>
  jimuMapView?: JimuMapView
  reportOptions?: any
  toggleUtilityErrorRemind: (isShow?: boolean) => void
}

export const print = async (option: PrintOption) => {
  const { mapView, printTemplateProperties, useUtility, isSupportReport, widgetId, useMapWidgetIds, jimuMapView, reportOptions, toggleUtilityErrorRemind } = option
  const session = await getSessionByUtility(Immutable(useUtility))
  return getUrlOfUseUtility(useUtility).then(printServiceUrl => {
    return loadArcGISJSAPIModules(['esri/rest/support/PrintParameters', 'esri/rest/support/PrintTemplate', 'esri/rest/print', 'esri/geometry/SpatialReference']).then(modules => {
      const [PrintParameters, PrintTemplate, print, SpatialReference] = modules
      const template = new PrintTemplate(printTemplateProperties)
      const newMapView = initHasZOfGrpahicInMap(mapView)
      const printParameter = {
        view: newMapView,
        template: template
      } as any
      if (printTemplateProperties.wkid !== mapView?.spatialReference?.wkid) {
        printParameter.outSpatialReference = new SpatialReference({ wkid: printTemplateProperties.wkid })
      }
      const params = new PrintParameters(printParameter)
      const queryOption = { timeout: 120000, token: session?.token }
      session?.token && (queryOption.token = session.token)

      return print.execute(printServiceUrl, params, queryOption).then((printResult) => {
        reportUtilityState(useUtility?.utilityId, toggleUtilityErrorRemind)
        isSupportReport && removeReportLayers(jimuMapView, reportOptions, widgetId, useMapWidgetIds)
        return Promise.resolve(printResult)
      }, err => {
        isSupportReport && removeReportLayers(jimuMapView, reportOptions, widgetId, useMapWidgetIds)
        reportUtilityState(useUtility?.utilityId, toggleUtilityErrorRemind, err)
        return Promise.reject(err)
      }).catch((printError) => {
        isSupportReport && removeReportLayers(jimuMapView, reportOptions, widgetId, useMapWidgetIds)
        reportUtilityState(useUtility?.utilityId, toggleUtilityErrorRemind, printError)
        return Promise.reject(printError)
      })
    })
  })
}

/**
 * Set the 'hasZ' of the layer and graphic generated by the Draw widget to 'false'
*/
function initHasZOfGrpahicInMap (mapView) {
  mapView.layerViews.items = mapView?.layerViews?.items?.map(views => {
    if (views?.layer?.id?.includes('jimu-draw-layer-') || views?.layer?.id?.includes('bookmark-layer-')) {
      views.graphicsView.graphics.items = views?.graphicsView?.graphics?.items?.map(graphic => {
        if (graphic?.attributes?.jimuDrawId) {
          graphic.geometry.hasZ = false
          return graphic
        } else {
          return graphic
        }
      })
      return views
    } else {
      return views
    }
  })
  return mapView
}

export async function getPrintTemplateInfo (useUtility?: UseUtility) {
  return getUrlOfUseUtility(useUtility).then(printServiceUrl => {

  })
}
